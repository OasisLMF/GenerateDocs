OasisLMF Package
================

|
On this page:
-------------
:ref:`intro_package`
:ref:`getting_started`
:ref:`MDK`



.. _intro_package:
|
Introduction
------------

The ``oasislmf`` Python package, loosely called the model development kit (MDK) or the MDK package, provides a command line 
toolkit for developing, testing and running Oasis models end-to-end locally, or remotely via the Oasis API. It can generate 
ground-up losses (GUL), direct/insured losses (IL) and reinsurance losses (RIL). It can also generate deterministic losses 
at all these levels.





.. 
   From wiki - Getting started

.. _getting_started:
|
Getting started:
****************

Welcome to the `OasisLMF <https://pypi.org/project/oasislmf/>`_ package. In this section, we will go through setting up our 
environment to run a basic pipeline using this package. We will achieve this with the following steps:

* Install `OasisLMF <https://pypi.org/project/oasislmf/>`_
* Generate fake test data
* Read events and stream them
* Construct a model
* Construct a python model
* Carrying out these steps will enable us to understand the basics of how the model pipeline works. It will also enable us 
to test our installation and contribute to the project.



Installing OasisLMF
###################

Installing OasisLMF is supported via `pip <https://pypi.org/project/oasislmf/>`_. This can be done by carrying out the 
command below:

.. code-block:: python

   pip install oasislmf

If we want to install the `OasisLMF <https://pypi.org/project/oasislmf/>`_ package in relation to a specific branch, we can 
carry out the command below:

.. code-block:: python

   pip install git+https://github.com/OasisLMF/OasisLMF@some-branch

With the command above, the branch ``some-branch`` can be substituted with whatever branch you want to install using pip. 
Now that our package is installed, we can move onto the next section, generating fake test data.



Generate fake test data
#######################

We need to generate fake test data in order for our model to take in a range of event IDs, and pass this through to a model 
that is constructed also using the data generated by the fake test data that we have generated. Right now, we just want to 
generate data that will not break the pipeline. This can be done by creating a 
`JSON <https://docs.python.org/3/library/json.html>`_ configuration file with the content below:

.. code-block:: JSON

   {
      "num_vulnerabilities": 50,
      "num_intensity_bins": 50,
      "num_damage_bins": 50,
      "vulnerability_sparseness": 0.5,
      "num_events": 10000,
      "num_areaperils": 100,
      "areaperils_per_event": 100,
      "intensity_sparseness": 0.5,
      "num_periods": 1000,
      "num_locations": 1000,
      "coverages_per_location": 3,
      "num_layers": 1
   }

The explanation of these values will be provided in another page later on. Right now, we just have to know that this will 
create a range of binary files that we can ingest for our model. Once this 
`JSON <https://docs.python.org/3/library/json.html>`_ file is saved, and we have access to this file, we can generate the 
data with the command below:

.. code-block:: python

   oasislmf test model generate-oasis-files -C oasislmf_dummyModel.json

Here we can see that the ``-C`` argument points to our `JSON <https://docs.python.org/3/library/json.html>`_  configuration 
file. Once this runs, we have the following file:

* **events.bin:** contains the event IDs that the model is going to compute
* **footprint.bin:** contains data about the probability of disasters occurring within an intensity bin in a geographical 
  location
* **footprint.idx:** contains the offset and location in the ``footprint.bin`` file for the model
* **vulnerability.bin:** contains the data about the probability of the disasters causing damage within a damage bin in a 
  geographical location
* **occurrence.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **damage_bin_dict.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **coverages.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **fm_policytc.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **fm_programme.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **fm_xref.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **fm_profile.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **fmsummaryxref.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **gulsummaryxref.bin:** [PLEASE ADD AN DESCRIPTION HERE]
* **items.bin:** [PLEASE ADD AN DESCRIPTION HERE]

We now have all the data that we need to run our model so we can move onto the next step of reading events and streaming 
them.



Read events and stream them
###########################

Before we read and stream the event IDs, we have to create an input directory and copy the events into this with the command 
below:

.. code-block:: python

   mkdir input && cp events.bin ./input/events.bin

We now have event IDs in our input directory so we can read and stream our event IDs with the command below:

.. code-block:: python

   eve 1 1

[ENTER DESCRIPTION ABOUT THE 1 1]

Running this gives us a byte stream that cannot be read by the human eyes as it looks like the printout snippet below:

.. code-block:: python

   �!�"�#�$�%�&�'�(�)�*�+�,�-�.�/�0�1�2

The ``getmodel`` that is next in the pipeline will process this stream. However, if you want to process this yourself in 
Python, this can be done using the `struct <https://docs.python.org/3/library/struct.html>`_ module with the code below:

.. code-block:: python

   import sys
   import struct

   data = sys.stdin.buffer.read()
   eve_raw_data = [data[i:i + 4] for i in range(0, len(data), 4)]
   eve_buffer = [struct.unpack("i", i)[0] for i in eve_raw_data]

Because the event IDs are integers. Because integers take up 4 bytes each, we loop through the data breaking it into chunks 
or 4 bytes and using the `struct <https://docs.python.org/3/library/struct.html>`_ module to unpack this giving us a list of 
integers that are event IDs. With this, we can move onto our next section which is constructing a model.



Construct a model
#################

Before we use a model, we have to ensure that the correct data is in the ``static`` and ``input`` directories with the 
command below:

.. code-block:: python

   mkdir static && cp footprint.bin ./static/footprint.bin && cp items.bin ./input/items.bin && cp vulnerability.bin ./static/vulnerability.bin && cp damage_bin_dict.bin ./static/damage_bin_dict.bin && cp footprint.idx ./static/footprint.idx

Now that our data is in the correct directories, we can run the ``getmodel`` command and dump the output into a ``csv`` file 
with the command below:

.. code-block:: python

   eve 1 1 | getmodel | cdftocsv > dump.csv

This streams the event IDs into the ``getmodel``, the model is then passed into the ``cdftocsv`` and the output of this is 
dumped into a ``csv`` file called ``dump.csv``. The outcome in the ``dump.csv`` will look similar to the outcome below:

.. csv-table::
    :header: "event_id", "areaperil_id", "vulnerability_id", "bin_index", "prob_to", "bin_mean"

    "1", "7", "3", "1", "0.104854", "0.00000"
    "1", "7", "3", "2", "0.288763", "0.0625 "
    "1", "7", "3", "3", "0.480476", "0.187500"
    "1", "7", "3", "4", "0.505688", "0.312500"
    "..", "..", "..", "..", "..", ".."
    "1", "7", "3", "10", "1", "1"
    "1", "7", "9", "1", "0.194455", "0.00000"



Here the ``prob_to`` is the probability of an event happening multiplied by the probability of damage happening. The 
probability of ``prob_to`` for all ``bin_indexs`` for a specific ``vulnerability_id``, ``areaperil_id``, and ``event_id``.



Construct a Python model
########################

When running a Python model, we have to define the type of file that we are ingesting. This is because we have only binary 
files and the Python model ingests ``csv`` files as default. We can run our Python model with the command below:

.. code-block:: python

   eve 1 1 | getpymodel -f bin | cdftocsv > dump_two.csv

This achieves the same as the previous section. However, it runs in the Python model so at this stage it will be slower. We 
have also dumped the data in the file ``dump_two.csv``.

We have now run a basic model with fake data. With this knowledge we can now move onto a toy example where we run an end to 
end model. We have not covered everything that goes on in the end to end model however, we know enough not to be completely 
lost. Instead, we should now know where to look to get further answers when looking at this toy example with a little 
guidance.



Running an end to end Toy model
###############################

Our toy model in the `Paris windstorm model <https://github.com/OasisLMF/ParisWindstormModel/tree/keys-lookup>`_. We need to 
clone the repo and ensure that we have `OasisLMF <https://pypi.org/project/oasislmf/>`_ pip package installed to run it. 
Once this is done, we can run our model with the command below:

.. code-block:: python

   oasislmf model run --config oasislmf_mdk.json

Here, we are running the model using the config file that is already defined in the repo. This will result in a lot of 
printout where the model is being created and then ran. We can see the result in the ``runs`` directory. Here we will see a 
losses directory with a random number which denotes the model run. If you run multiple models you will see multiple losses 
directories with multiple unique IDs. So, building on what we learnt in the previous sections we can inspect the bash script 
below:

.. code-block:: python

   ParisWindstormModel/runs/losses-XXXXXXXXXXXXXX/run_ktools.sh

This bash script is essentially the entire process of constructing the model and running it. There is a lot of moving parts 
here that we have not covered yet, however, if we scroll down we can see the something we kind of understand as seen below:

.. code-block:: python

   ( eve 1 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 2 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 3 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 4 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 5 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 6 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 7 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...
   ( eve 8 8 | getmodel | gulcalc -S10 -L0 -a0 -i ...

Here we have split our events into eight different streams and fed them into our getmodel and then fed the results of the 
getmodel to the rest of the process.










..
   From MDK on github.io

.. _MDK:
|
Model Development Kit (MDK)
***************************

The oasislmf Python package comes with a command line interface for creating, testing and managing models.
The tool is split into several namespaces that group similar commands. 
For a full list of namespaces use ``oasislmf --help``, and ``oasislmf <namespace> --help`` for a full list of commands 
available in each namespace.

config
######

.. autocli:: oasislmf.cli.config.ConfigCmd
   :noindex:


model
#####


``oasislmf model generate-exposure-pre-analysis``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.GenerateExposurePreAnalysisCmd
   :noindex:


``oasislmf model generate-keys``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.GenerateKeysCmd
   :noindex:

``oasislmf model generate-losses``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.GenerateLossesCmd
   :noindex:

``oasislmf model generate-oasis-files``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.GenerateOasisFilesCmd
   :noindex:

``oasislmf model run``
^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.RunCmd
   :noindex:

exposure
########

``oasislmf exposure run``
^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.model.RunCmd
   :noindex:

API client 
##########

``oasislmf api run``
^^^^^^^^^^^^^^^^^^^^^^^^^

.. autocli:: oasislmf.cli.api.RunApiCmd
   :noindex:



version
#######

.. autocli:: oasislmf.cli.version.VersionCmd
   :noindex:




Run a model using the Oasis MDK 
###############################

The Model Development Kit (MDK) is the best way to get started using the Oasis platform.
The MDK is a command line tookit providing command line access to Oasis' modelling functionality. 
It is installed as a Python package, and available from PYPI: `OasisLMF PYPI module <https://pypi.python.org/pypi/oasislmf>`_.

The OasisLMF package has the following dependencies:

*Debian*: 
    g++, build-essential, libtool, zlib1g-dev, autoconf, unixobdbc-dev
*RHEL*:
    Development Tools, zlib-devel

To install the OasisLMF package run:

.. code-block:: python

    pip install oasislmf

.. warning:: Windows is not directly supported for running the MDK.
    You can run the Oasis MDK on Linux or MacOS.
    You can only run on Windows using a docker container or Linux Subsystem (WSL).

